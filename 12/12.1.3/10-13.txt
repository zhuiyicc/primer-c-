10.正确，shared_ptr(p)创建一个临时对象，作为实参拷贝给process的形参，但实际上这并不会影响到p的引用计数。
11.错误，shared_ptr(p.get())创建一个临时对象，但这个对象实际上其计数并不等于2(因为它和p是两个独立的shared_ptr，只不过它们指向了同一个内存)，
因此在process调用完之后，p指向的内存实际上已经被释放掉了(因为临时对象被销毁了，其指向的内存也被free)，因此p指针实际上已经成为了一个野指针。
除非我们能够很轻易的得到指向某个内存的指针数量(然后改变引用计数)，否则不应该利用shared_ptr的get()来初始化另一个shared_ptr，因为它们并不会把计数
改变，而是认为它们并未共享同一个内存。
12.(b),(c)shared_ptr不能进行隐式转换，(a)正确，如上述10，(d)错误，p被释放掉了，后续不能直接解引用p。
13.sp的计数并不会改变，而p被释放掉了，后续sp在执行析构函数时会free p而报错。
